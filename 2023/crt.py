#https://rosettacode.org/wiki/Chinese_remainder_theorem#Python
from functools import reduce
from operator import mul    

def chinese_remainder(n, a):
    """
    Chinese Remainder Theorem.

    :param n: list of pairwise relatively prime integers
    :param a: remainders when x is divided by n
    """
    s = 0
    prod = reduce(mul, n)
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        s += a_i * inverse(p, n_i) * p
    return s % prod    

def inverse(a, b):
    """
    Modular multiplicative inverse.
    """
    b0 = b
    x0, x1 = 0, 1
    if b == 1:
        return 1
    while a > 1:
        q = a // b
        a, b = b, a % b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += b0
    return x1    

ax = [0,0,0,0,0,1,3,6,8,10,10,11,13,13,16,18,19,19,24,25,28,28,30,32,33,34,36,36,36,52,56,70,96,114,118,128,133,144,146,177,181,238,]
nx = [2,3,5,23,41,11,19,7,113,13,37,17,97,151,47,59,107,131,53,29,31,43,109,73,61,67,71,79,89,101,139,83,193,137,157,191,263,197,257,223,199,241,]
x = chinese_remainder(nx,ax)
ay = [0,0,0,0,0,2,2,3,3,4,4,6,9,10,10,10,16,18,20,21,22,25,25,31,34,35,35,37,44,45,48,50,51,57,59,60,64,66,67,75,78,81,83,83,88,96,111,111,112,129,142,149,157,163,164,188,189,210,218,220,240,255,263,370,441,595,843,1113,]
ny = [2,3,5,7,71,19,101,37,307,11,17,97,13,23,29,41,191,31,277,107,463,59,89,181,157,79,131,43,53,47,83,151,239,103,61,353,67,139,73,113,193,499,109,389,347,281,293,373,211,229,167,179,163,251,269,397,409,223,283,227,271,683,619,547,479,739,863,1249,]
y = chinese_remainder(ny,ay)
az = [0,0,1,2,3,3,4,4,8,8,9,9,13,14,14,19,22,23,26,30,35,35,35,36,38,44,47,49,49,53,54,54,56,59,60,64,66,81,83,93,101,104,122,130,138,140,141,146,153,163,174,177,202,203,221,295,]
nz = [3,167,2,113,5,13,7,157,19,41,11,23,17,29,67,281,47,31,37,233,43,89,131,79,59,53,73,61,97,109,127,181,71,83,103,263,101,137,317,139,107,227,173,337,193,283,197,163,179,199,229,191,257,463,223,311,]
z = chinese_remainder(nz,az)
print(x,y,z,x+y+z)


